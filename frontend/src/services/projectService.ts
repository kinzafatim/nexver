import { Project, VerificationPlanRow, VPSheet } from "../types";

// --- MOCK DATABASE ---
// In a real application, this data would live in your Django backend.
// These service functions would make fetch/axios calls to retrieve it.

const mockVerificationPlanHTML = `
<div class="p-8 bg-white dark:bg-secondary-900 rounded-lg shadow-inner font-sans text-sm text-gray-800 dark:text-gray-200">
    <h1 class="text-2xl font-bold border-b-2 border-primary-500 pb-2 mb-4 text-primary-700 dark:text-primary-300">Verification Plan: PicoCPU Core</h1>
    <p class="mb-4 text-xs text-gray-500 dark:text-gray-400">Document Version: 1.0 | Generated: ${new Date().toLocaleDateString()}</p>
    
    <h2 class="text-lg font-semibold mt-6 mb-2 text-primary-600 dark:text-primary-400">1. Overview</h2>
    <p>This document outlines the verification strategy for the PicoCPU core. The primary objective is to ensure functional correctness and adherence to the specification document.</p>
</div>
`;

const mockVerificationPlanMarkdown = `
# Verification Plan: PicoCPU Core

**Version: 1.0 | Generated: ${new Date().toLocaleDateString()}**

## 1. Overview
This document outlines the verification strategy for the PicoCPU core. The primary objective is to ensure functional correctness and adherence to the specification document.
`;

const mockVerificationPlanExtraSheets: VPSheet[] = [
    {
        name: 'Coverage Goals',
        headers: ['Coverage Type', 'Goal', 'Exclusions', 'Current'],
        rows: [
            ['Code Coverage', '> 95% statement & branch', 'Reset sequence', '96%'],
            ['Functional Coverage', '100% for all covergroups', 'N/A', '92%'],
            ['Assertion Coverage', '100% pass rate', 'N/A', '100%'],
        ]
    },
    {
        name: 'Test Plan',
        headers: ['Test ID', 'Description', 'Features Covered', 'Status'],
        rows: [
            ['TEST-001', 'ALU add/sub random', 'FEAT-003', 'Pass'],
            ['TEST-002', 'ALU logic ops random', 'FEAT-003', 'Pass'],
            ['TEST-003', 'Register file access', 'FEAT-002', 'Fail'],
            ['TEST-004', 'Memory unaligned access', 'FEAT-004', 'Not Run'],
        ]
    }
];

const mockVerificationPlanTableData: VerificationPlanRow[] = [
    {
      id: 1,
      feature: 'Reset',
      subFeature: 'Power-on Reset',
      description: 'Check that all registers and state machines go to their default values upon power-on.',
      verificationGoal: 'Ensure all specified registers are at their default values after the first clock cycle following de-assertion of reset.',
      source: 'spec.pdf#page=12',
    },
    {
      id: 2,
      feature: 'Data Path',
      subFeature: 'FIFO Operation',
      description: 'Verify the First-In-First-Out behavior of the main data buffer.',
      verificationGoal: 'Write a sequence of unique data words and read them back to confirm order and integrity.',
      source: 'spec.pdf#page=25',
    },
];

export const mockSpecificationContent: Record<string, string> = {
    'spec.pdf#page=12': `**Section 3.1: Reset**\n\nUpon power-on reset (POR), the system must initialize to a known default state. The 'rst_n' signal, when asserted low, will asynchronously reset all control registers and state machines. All registers listed in Appendix A must return to their specified default values on the first rising edge of 'clk' after 'rst_n' is de-asserted.`,
    'spec.pdf#page=25': `**Section 5.2: FIFO Buffer**\n\nThe main data path includes a 32-word deep, 32-bit wide synchronous FIFO buffer. Data is written on the rising edge of 'clk' when 'wr_en' is high and 'full' is low. Data is read on the rising edge of 'clk' when 'rd_en' is high and 'empty' is low. The FIFO must maintain the order of data written.`,
};

export const mockTestbenchCode = `
// Generated by NexVer
// Testbench Top: tb_top.sv
\`include "uvm_macros.svh"
import uvm_pkg::*;
// ... more code
`;

export const mockTestcaseCode = `
// Generated by NexVer
// Testcase: alu_add_test.sv
class alu_add_test extends base_test;
  \`uvm_component_utils(alu_add_test)
// ... more code
`;

const mockProjects: Project[] = [
    {
        name: 'RISC-V_Core_Verification',
        location: 'D:\\projects\\riscv_core',
        specFiles: [{ name: 'ISA_Spec_v2.2.pdf', type: 'Spec' }],
        history: [
            { id: 1, event: 'Project "RISC-V_Core_Verification" created.', timestamp: new Date('2023-10-26T10:00:00Z') },
        ],
        logs: [
            { id: 1, message: 'Project initialized successfully.', type: 'success', timestamp: new Date('2023-10-26T10:00:00Z') },
        ],
        verificationPlan: mockVerificationPlanMarkdown,
        verificationPlanData: mockVerificationPlanTableData,
        verificationPlanSheets: mockVerificationPlanExtraSheets,
    },
    {
        name: 'AXI_Bus_Interconnect_Test',
        location: 'C:\\verification\\axi_bus',
        specFiles: [{ name: 'AXI4_spec.pdf', type: 'Spec' }],
        history: [
             { id: 1, event: 'Project "AXI_Bus_Interconnect_Test" created.', timestamp: new Date('2023-11-15T14:30:00Z') },
        ],
        logs: [
            { id: 1, message: 'Waiting for files to be uploaded.', type: 'info', timestamp: new Date() }
        ],
    }
];

// --- API-LIKE SERVICE FUNCTIONS ---

/**
 * Fetches a list of all existing projects.
 * In the future, this will make a GET request to /api/v1/projects/
 */
export const getProjects = async (): Promise<Project[]> => {
    console.log("SERVICE: Fetching projects...");
    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate network delay
    return mockProjects;
};

/**
 * Fetches detailed information for a single project.
 * In the future, this will make a GET request to /api/v1/projects/{projectName}/
 */
export const getProjectDetails = async (projectName: string): Promise<Project> => {
    console.log(`SERVICE: Fetching details for ${projectName}...`);
    await new Promise(resolve => setTimeout(resolve, 300));
    const project = mockProjects.find(p => p.name === projectName);
    if (!project) {
        throw new Error("Project not found");
    }
    return project;
};


/**
 * Creates a new project.
 * In the future, this will make a POST request to /api/v1/projects/
 */
export const createProject = async (name: string): Promise<Project> => {
    console.log(`SERVICE: Creating project "${name}"...`);
    await new Promise(resolve => setTimeout(resolve, 400));
    const location = `C:\\Users\\user\\Documents\\NexVer_Projects\\${name}`;
    const newProject: Project = {
        name,
        location,
        specFiles: [],
        history: [{ id: Date.now(), event: `Project "${name}" created.`, timestamp: new Date() }],
        logs: [{ id: Date.now(), message: `Project created. Waiting for file uploads.`, type: 'info', timestamp: new Date() }]
    };
    // In a real app, you wouldn't push to a local array. The backend would handle persistence.
    mockProjects.push(newProject);
    return newProject;
};

/**
 * Simulates uploading files to a project.
 * In the future, this will make a POST request with multipart/form-data to /api/v1/projects/{projectName}/upload/
 */
export const uploadFiles = async (projectName: string, files: {name: string, type: 'Spec'}[]): Promise<Project> => {
    console.log(`SERVICE: Uploading ${files.length} files to ${projectName}...`);
    await new Promise(resolve => setTimeout(resolve, 800));
    const project = mockProjects.find(p => p.name === projectName);
    if (!project) throw new Error("Project not found");
    
    project.specFiles.push(...files);
    return project;
};


/**
 * Simulates the AI generation of a Verification Plan.
 * In the future, this will trigger a backend process via a POST to /api/v1/projects/{projectName}/generate-vp/
 */
export const generateVerificationPlan = async (projectName: string): Promise<Pick<Project, 'verificationPlan' | 'verificationPlanData' | 'verificationPlanSheets'>> => {
    console.log(`SERVICE: Generating Verification Plan for ${projectName}...`);
    await new Promise(resolve => setTimeout(resolve, 2500));
    return {
        verificationPlan: mockVerificationPlanMarkdown,
        verificationPlanData: mockVerificationPlanTableData,
        verificationPlanSheets: mockVerificationPlanExtraSheets
    }
}

/**
 * Simulates the AI generation of a Testbench.
 * In the future, this will trigger a backend process via a POST to /api/v1/projects/{projectName}/generate-tb/
 */
export const generateTestbench = async (projectName: string): Promise<boolean> => {
    console.log(`SERVICE: Generating Testbench for ${projectName}...`);
    await new Promise(resolve => setTimeout(resolve, 2500));
    return true; // Return success status
}
